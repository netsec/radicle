#!/usr/bin/env radicle

(load! (find-module-file! "prelude.rad"))
(load! (find-module-file! "monadic/registry.rad"))
(file-module! "prelude/io-utils.rad")
(file-module! "prelude/error-messages.rad")
(file-module! "monadic/items.rad")

(import prelude/error-messages :as 'error)
(import monadic/items :as 'items)
(import prelude/strings '[split-by] :unqualified)
(import prelude/validation :as 'validation)
(import prelude/machine :as 'machine)

;; (import monadic/registry '[create-registry-machine!] :unqualified)

(def machine-name (fn [] "12D3KooWNdyJ1QpNy5RbBfjKEx1gPvRJ72tgYo1vs6jvXU8yuQN2"))

(def valid-states ["open" "closed"])

(def status-opts ["--filter-by-state" "--state" "-s"])

(def list-opts-help
  (string-append
    "[("
    (string/intercalate " | " status-opts)
    ") <state>]"))

(def help
  (string-append
  "rad registry - Radicle Registry CLI

   Usage:
        rad registry list " list-opts-help "
        rad registry new
        rad registry [show | close | mark-read | mark-unread] <project-number>
        rad registry all-read
        rad init
        rad registry help

     list         - Lists all projects
                    The list can be filtered by state:
                      " (string/intercalate ", " valid-states) "
                    The flags for filtering by state:
                      " (string/intercalate ", " status-opts) "
                    Filtering by multiple states is possible via '-s <state1> -s
                    <state2> ...'.
                    If the option '--unread' is appended, only unread projects
                    are listed.
                    Unread projects are marked with a * after the timestamp.
     new          - Register a new project in $EDITOR
     show         - Show a project
     show-id      - Show the project id
     close        - Close a project
                    This command is restricted to the maintainer of the project.
     mark-read    - Mark project as read
     mark-unread  - Mark project as unread
     all-read     - Mark all projects as read
     init         - Initialize a new register machine
     help         - Print this help and exit
       "))

(def cmd-parse-failure
  (fn [error]
    (parse-failure error help)))

(def show-project!
  "Shows a single PROJECT `n`"
  (fn [n machine]
    (def project (items/verify-item-number n (list-projects machine) :project))
    (put-str! (items/pretty-item-view (items/enrich-item machine project)))
    (newness/mark-read! machine n)))

(def show-project-id!
  "Shows the id of a single PROJECT `n`"
  (fn [n machine]
    (def project (items/verify-item-number n (list-projects machine) :project))
    (put-str! (lookup :project-id project))
    (newness/mark-read! machine n)))

(def close-project
  (fn [n machine]
    (catch 'daemon-error
      (do
        (items/verify-item-number n (list-projects machine) :project)
        (simple-edit-project! machine n {:state :closed})
        (put-str! (string-append "Project #" (show n) " has been closed."))
        (newness/mark-read! machine n))
      (fn [_]
        (put-str! (error/state-change-failure :project "closed"))
        (exit! 1)))))

(def list
  (fn [machine options]
    (def projects (values (list-projects machine)))
    (items/list-items machine options projects :project (fn [] ""))))

(def prompt-for-metadata!
  (fn []
    (def name (prompt! "? What's the name of your project: "))
    (def desc (prompt! "? Briefly describe the project: "))
    (def id (prompt! "? What's the id of your project: "))
    (def labels (prompt! "? Do you want to add any labels (comma seperated): "))
    {:name name :description desc :project-id id :labels (split-by (fn [x] (eq? x ",")) labels)}))

(def new-project
  (fn [machine]
    (def meta (prompt-for-metadata!))
    (def author {:git-username (get-git-username!)})
    (match (register-project!  machine (simple-project (<> meta author)))
           ['n] (do (put-str! (string-append "Created project #" (show n) " in " machine))
                    (newness/mark-read! machine n))
           _    (put-str! (error/no-number-returned :project)))))

(def cmd-options
  [
    { :key :state :type :multi-opt :options ["-s" "--state" "--filter-by-state"] :possible-values valid-states :default ["open"]}
    { :key :unread :type :flag :options ["--unread"] :default #f }
  ])

(def /list-cmd
  (fn [opts]
    (/cmd-opts "list" opts cmd-options help)))

(def args (get-args!))

(def whole-project-num
  (fn [action num-str f]
    (whole-num help :project action num-str f)))

(def mark-all-read!
  (fn [machine]
    (map (fn [i] (newness/mark-read! machine (lookup :number i)))
         (values (list-projects machine)))))

(def new-registry!
  (fn []
    (def registry (create-registry-machine!))
    (put-str! "=> Assembled rad registry machine")
    (put-str! (string-append "=> registry id: " registry))))

(machine/catch-daemon!
 (fn []
   (match args
          (/list-cmd 'options)           (list (machine-name) options)
          (/cmd-0 "new" help)            (new-project (machine-name))
          (/cmd-0 "init" help)           (new-registry!)
          (/cmd-1 "close" 'n help)       (whole-project-num "close" n (fn [n] (close-project n (machine-name))))
          (/cmd-1 "show" 'n help)        (whole-project-num "show" n (fn [n] (show-project! n (machine-name))))
          (/cmd-1 "show-id" 'n help)     (whole-project-num "show-id" n (fn [n] (show-project-id! n (machine-name))))
          (/cmd-1 "mark-read" 'n help)   (whole-project-num "mark as read" n (fn [n] (newness/mark-read! (machine-name) n)))
          (/cmd-1 "mark-unread" 'n help) (whole-project-num "mark as unread" n (fn [n] (newness/mark-unread! (machine-name) n)))
          (/cmd-0 "all-read" help)       (mark-all-read! (machine-name))
          (/cmd-help)                    (put-str! help)
          (/cons 'cmd _)                 (cmd-parse-failure (error/unknown-command cmd))
          []                             (put-str! help))))
